# Vulnerability Identification Guide

**Purpose:** This guide demonstrates how to identify common security vulnerabilities in web applications.

**Date:** February 3, 2026  
**Application:** SafeVault - Educational Security Demonstration

---

## Overview

This guide covers the systematic identification of SQL injection and Cross-Site Scripting (XSS) vulnerabilities in web applications. It includes manual code review techniques, automated scanning methods, and practical examples from the SafeVault application.

---

## Table of Contents

1. [SQL Injection Detection](#sql-injection-detection)
2. [Cross-Site Scripting (XSS) Detection](#cross-site-scripting-xss-detection)
3. [Manual Code Review Checklist](#manual-code-review-checklist)
4. [Automated Scanning Tools](#automated-scanning-tools)
5. [Testing for Vulnerabilities](#testing-for-vulnerabilities)
6. [Common Vulnerability Patterns](#common-vulnerability-patterns)

---

## SQL Injection Detection

### What is SQL Injection?

SQL injection occurs when untrusted data is concatenated directly into SQL queries, allowing attackers to manipulate the query logic.

### Detection Techniques

#### 1. Look for String Concatenation in SQL Queries

**Vulnerable Pattern:**

```csharp
// DANGEROUS: String interpolation in SQL
var sqlQuery = $"SELECT * FROM Users WHERE Username = '{username}'";
var users = await db.Users.FromSqlRaw(sqlQuery).ToListAsync();
```

**Red Flags:**
- `$"SELECT ... {variable}"` - String interpolation
- `"SELECT ..." + variable` - String concatenation
- `FromSqlRaw()` with user input
- Dynamic SQL construction

#### 2. Check for Missing Parameterization

**Questions to Ask:**
- Are user inputs being passed directly into SQL queries?
- Is `FromSqlRaw` being used instead of LINQ queries?
- Are there any string operations (`+`, `$""`) near SQL keywords?

#### 3. Review Query Construction

**Vulnerable Code Example:**

```csharp
// VULNERABLE: Email search with string interpolation
app.MapGet("/vulnerable/search-email", async (string email, SafeVaultContext db) =>
{
    var sqlQuery = $"SELECT * FROM Users WHERE Email = '{email}'";
    var users = await db.Users.FromSqlRaw(sqlQuery).ToListAsync();
    return Results.Ok(users);
});
```

**Attack Vector:**
```
Input: test@example.com' OR '1'='1
Resulting Query: SELECT * FROM Users WHERE Email = 'test@example.com' OR '1'='1'
Result: Returns ALL users (authentication bypass)
```

### SQL Injection Attack Patterns

| Pattern | Description | Example Input |
|---------|-------------|---------------|
| **Authentication Bypass** | Always-true condition | `admin' OR '1'='1` |
| **Comment Injection** | Comment out rest of query | `admin'--` |
| **UNION Attack** | Extract data from other tables | `' UNION SELECT * FROM Users--` |
| **Stacked Queries** | Execute multiple commands | `'; DROP TABLE Users; --` |
| **Blind SQLi** | Extract data character by character | `' AND SUBSTRING((SELECT Password FROM Users WHERE Username='admin'),1,1)='a` |

### Identification Checklist

- [ ] Scan for `FromSqlRaw` usage
- [ ] Look for string interpolation (`$""`) near SQL keywords
- [ ] Check for string concatenation (`+`) with SQL queries
- [ ] Verify parameterization is used
- [ ] Test with malicious input (in test environment)

---

## Cross-Site Scripting (XSS) Detection

### What is XSS?

XSS occurs when untrusted data is included in web pages without proper encoding, allowing attackers to inject malicious scripts.

### Detection Techniques

#### 1. Look for Missing HTML Encoding

**Vulnerable Pattern:**

```csharp
// DANGEROUS: No HTML encoding
return Results.Content($@"
    <html>
    <body>
        <p>Username: {user.Username}</p>
    </body>
    </html>
", "text/html");
```

**Red Flags:**
- User input directly in HTML responses
- Missing `HtmlEncode()` calls
- Raw string output in JSON/HTML
- Dynamic HTML construction

#### 2. Check for Missing Input Validation

**Vulnerable Pattern:**

```csharp
// DANGEROUS: No input validation
var comment = form["comment"].ToString();
return Results.Ok(new { message = $"Comment: {comment}" });
```

**Red Flags:**
- Direct use of form data
- No validation before output
- Missing sanitization
- No length limits

#### 3. Review Output Encoding

**Questions to Ask:**
- Is user input being encoded before output?
- Are `HtmlEncode()` or similar functions used?
- Is validation performed on all inputs?
- Are there any direct string interpolations with user data?

### XSS Attack Patterns

| Type | Description | Example Input |
|------|-------------|---------------|
| **Script Tag** | Direct script injection | `<script>alert('XSS')</script>` |
| **Event Handler** | JavaScript in HTML attributes | `<img src=x onerror=alert('XSS')>` |
| **JavaScript Protocol** | JavaScript in URLs | `<a href='javascript:alert(1)'>click</a>` |
| **SVG-based** | Script in SVG tags | `<svg onload=alert('XSS')>` |
| **Data URI** | Base64 encoded scripts | `<iframe src='data:text/html;base64,...'>` |
| **HTML Injection** | Inject HTML structure | `</div><h1>Fake</h1>` |

### XSS Identification Checklist

- [ ] Scan for `Results.Content` with `text/html`
- [ ] Look for string interpolation without encoding
- [ ] Check for missing `HtmlEncode()` calls
- [ ] Verify input validation exists
- [ ] Test with XSS payloads (in test environment)

---

## Manual Code Review Checklist

### Step-by-Step Review Process

#### Phase 1: Preparation

1. **Understand the Application Flow**
   - Identify all input points (forms, query parameters, APIs)
   - Map out data flow from input to database to output
   - Identify sensitive operations (authentication, data access)

2. **Gather Code Artifacts**
   - Source code files
   - Database queries
   - API endpoints
   - Configuration files

#### Phase 2: SQL Injection Review

```
✓ Step 1: Search for SQL-related code
  - Grep for: SELECT, INSERT, UPDATE, DELETE, FromSqlRaw
  - Look in: Controllers, Services, Data Access Layer

✓ Step 2: Analyze query construction
  - Check each query for string concatenation
  - Verify parameterization is used
  - Look for dynamic SQL generation

✓ Step 3: Test critical paths
  - Login endpoints
  - Search functionality
  - Data retrieval operations
```

#### Phase 3: XSS Review

```
✓ Step 1: Search for output operations
  - Grep for: Results.Content, Response.Write, HTML generation
  - Look in: Controllers, Views, API responses

✓ Step 2: Analyze encoding
  - Check for HtmlEncode() usage
  - Verify input validation
  - Look for raw string output

✓ Step 3: Test output paths
  - User profile displays
  - Comment sections
  - Search result pages
```

#### Phase 4: Input Validation Review

```
✓ Step 1: Identify input points
  - Form fields
  - Query parameters
  - Request body
  - Headers/cookies

✓ Step 2: Check validation logic
  - Is validation present?
  - Is it comprehensive?
  - Are there length limits?
  - Are dangerous characters blocked?

✓ Step 3: Test bypass attempts
  - Encoding variations
  - Case sensitivity
  - Unicode characters
```

### Quick Reference: Dangerous Patterns

```csharp
// ❌ SQL INJECTION RISKS
FromSqlRaw($"SELECT * FROM Users WHERE Id = {id}")
"SELECT * FROM " + tableName + " WHERE..."
ExecuteRawSql(userInput)

// ❌ XSS RISKS
Results.Content($"<html>{userInput}</html>", "text/html")
Response.Write(comment)
new { message = $"Hello {username}" }

// ❌ MISSING VALIDATION
var data = form["input"].ToString(); // Direct use
if (string.IsNullOrEmpty(input)) { } // Insufficient validation

// ✅ SECURE PATTERNS
db.Users.Where(u => u.Id == id) // Parameterized
HtmlEncode(userInput) // Encoded output
validator.Validate(input) // Comprehensive validation
```

---

## Automated Scanning Tools

### Using the VulnerabilityScanner

The SafeVault application includes a built-in vulnerability scanner in `Tools/VulnerabilityScanner.cs`.

**Usage Example:**

```csharp
// Read the code file
string code = File.ReadAllText("Program.cs");

// Perform comprehensive scan
var scanResult = VulnerabilityScanner.PerformSecurityScan(code);

// Generate report
Console.WriteLine(scanResult.GenerateReport());
```

**Output:**

```
╔══════════════════════════════════════════════════════════╗
║           SECURITY VULNERABILITY SCAN REPORT            ║
╠══════════════════════════════════════════════════════════╣
║  Total Issues:        6                                  ║
║  Critical:            2                                  ║
║  High:                3                                  ║
║  Medium:              1                                  ║
╚══════════════════════════════════════════════════════════╝

SQL INJECTION VULNERABILITIES:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  [CRITICAL] FromSqlRaw with String Interpolation
  Description: FromSqlRaw is being used with string interpolation
  Fix: Use parameterized queries with FromSqlInterpolated

XSS VULNERABILITIES:
━━━━━━━━━━━━━━━━━━━━
  [HIGH] HTML Response without Encoding
  Description: HTML content returned without proper encoding
  Fix: Use System.Web.HttpUtility.HtmlEncode()
```

### Scanner Capabilities

1. **SQL Injection Detection**
   - String interpolation in SQL queries
   - `FromSqlRaw` with dynamic input
   - String concatenation patterns

2. **XSS Detection**
   - Missing `HtmlEncode` in HTML responses
   - Unencoded user input in messages
   - Missing input validation

3. **Authorization Issues**
   - Endpoints without authentication
   - Missing authorization requirements

---

## Testing for Vulnerabilities

### Manual Testing Process

#### Testing for SQL Injection

**Test Inputs:**

```
# Authentication Bypass
admin' OR '1'='1
' OR 1=1--
admin'--

# Union-based Extraction
' UNION SELECT * FROM Users--
' UNION SELECT null,Username,Password FROM Users--

# Blind SQLi
' AND 1=1--
' AND 1=2--

# Time-based
'; WAITFOR DELAY '00:00:05'--

# Stacked Queries
'; DROP TABLE Users; --
```

**Expected Secure Response:**
- Input validation rejects malicious patterns
- Parameterized queries treat input as literal string
- Generic error messages (no SQL error details)
- No data extraction or manipulation occurs

#### Testing for XSS

**Test Inputs:**

```html
<!-- Script Tag -->
<script>alert('XSS')</script>

<!-- Event Handler -->
<img src=x onerror=alert('XSS')>

<!-- JavaScript Protocol -->
<a href='javascript:alert(1)'>click</a>

<!-- SVG-based -->
<svg onload=alert('XSS')>

<!-- Data URI -->
<iframe src='data:text/html,<script>alert(1)</script>'>

<!-- HTML Injection -->
</div><h1>Injected</h1><div>
```

**Expected Secure Response:**
- Input validation blocks malicious patterns
- HTML encoding converts dangerous characters
- Script tags appear as text (not executed)
- No HTML structure manipulation

---

## Common Vulnerability Patterns

### Pattern 1: Direct User Input in SQL

```csharp
// VULNERABLE
var result = await db.Users
    .FromSqlRaw($"SELECT * FROM Users WHERE Username = '{username}'")
    .ToListAsync();

// SECURE
var result = await db.Users
    .Where(u => u.Username == username)
    .ToListAsync();
```

### Pattern 2: Unencoded Output

```csharp
// VULNERABLE
return Results.Content($"<div>{userInput}</div>", "text/html");

// SECURE
var encoded = HtmlEncode(userInput);
return Results.Content($"<div>{encoded}</div>", "text/html");
```

### Pattern 3: Missing Input Validation

```csharp
// VULNERABLE
var comment = form["comment"].ToString();
// Direct use without validation

// SECURE
var comment = form["comment"].ToString();
var validation = validator.ValidateComment(comment);
if (!validation.IsValid) {
    return Results.BadRequest(new { errors = validation.Errors });
}
```

### Pattern 4: Information Disclosure

```csharp
// VULNERABLE
catch (Exception ex) {
    return Results.BadRequest(new { error = ex.Message });
}

// SECURE
catch (Exception ex) {
    // Log the detailed error internally
    logger.LogError(ex, "Error processing request");
    // Return generic message to user
    return Results.StatusCode(500);
}
```

---

## Key Takeaways

### Signs of SQL Injection

1. String concatenation with SQL keywords
2. `FromSqlRaw` with user input
3. Dynamic SQL construction
4. Missing parameterization

### Signs of XSS

1. User input in HTML without encoding
2. Missing `HtmlEncode()` calls
3. No input validation
4. Raw output in responses

### Remediation Priority

**Critical (Fix Immediately):**
- SQL injection in authentication
- XSS in user-generated content
- Unvalidated data in queries

**High (Fix Soon):**
- Missing input validation
- Inadequate output encoding
- Information disclosure in errors

**Medium (Address in Next Sprint):**
- Missing length limits
- Insufficient error handling
- Authorization gaps

---

## Conclusion

Effective vulnerability identification requires:

1. **Systematic Code Review** - Follow the checklist methodically
2. **Automated Scanning** - Use tools to catch common patterns
3. **Manual Testing** - Test with actual attack payloads
4. **Defense in Depth** - Multiple layers of security
5. **Continuous Monitoring** - Regular security audits

**Remember:** Prevention is better than detection. Build security in from the start.

---

**Related Resources:**
- [VULNERABILITY_REMEDIATION_REPORT.md](VULNERABILITY_REMEDIATION_REPORT.md) - Remediation guidance
- [SECURITY_BEST_PRACTICES.md](SECURITY_BEST_PRACTICES.md) - Secure coding guidelines
- [OWASP Top 10](https://owasp.org/www-project-top-ten/) - Web application security risks

**Report Generated:** February 3, 2026  
**Version:** 1.0  
**Classification:** Educational Material
