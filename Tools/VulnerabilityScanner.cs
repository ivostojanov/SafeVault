using System.Text.RegularExpressions;

namespace SafeVault.Tools
{
    /// <summary>
    /// Simple static code analyzer that identifies common security vulnerability patterns.
    /// This is a basic implementation for educational purposes.
    /// </summary>
    public class VulnerabilityScanner
    {
        /// <summary>
        /// Scans code for potential SQL injection vulnerabilities.
        /// </summary>
        public static List<VulnerabilityReport> ScanForSqlInjection(string code)
        {
            var vulnerabilities = new List<VulnerabilityReport>();

            // Pattern 1: String interpolation in SQL queries
            var sqlInterpolationPattern = @"\$"".*SELECT.*FROM.*\{.*\}";
            if (Regex.IsMatch(code, sqlInterpolationPattern, RegexOptions.IgnoreCase | RegexOptions.Singleline))
            {
                vulnerabilities.Add(new VulnerabilityReport
                {
                    Type = "SQL Injection",
                    Severity = "HIGH",
                    Location = "SQL Query with String Interpolation",
                    Description = "Detected string interpolation in SQL query. This creates SQL injection vulnerability.",
                    Recommendation = "Use parameterized queries or LINQ queries with Entity Framework Core."
                });
            }

            // Pattern 2: FromSqlRaw with string concatenation
            var fromSqlRawPattern = @"FromSqlRaw\s*\(\s*\$""";
            if (Regex.IsMatch(code, fromSqlRawPattern, RegexOptions.IgnoreCase))
            {
                vulnerabilities.Add(new VulnerabilityReport
                {
                    Type = "SQL Injection",
                    Severity = "CRITICAL",
                    Location = "FromSqlRaw with String Interpolation",
                    Description = "FromSqlRaw is being used with string interpolation, allowing SQL injection attacks.",
                    Recommendation = "Use parameterized queries with FromSqlInterpolated or use LINQ Where() clauses."
                });
            }

            // Pattern 3: String concatenation with SQL keywords
            var sqlConcatPattern = @"""SELECT\s+.*FROM.*""\s*\+";
            if (Regex.IsMatch(code, sqlConcatPattern, RegexOptions.IgnoreCase))
            {
                vulnerabilities.Add(new VulnerabilityReport
                {
                    Type = "SQL Injection",
                    Severity = "CRITICAL",
                    Location = "SQL Query with String Concatenation",
                    Description = "SQL query is being constructed using string concatenation.",
                    Recommendation = "Never concatenate user input into SQL queries. Use parameterized queries."
                });
            }

            return vulnerabilities;
        }

        /// <summary>
        /// Scans code for potential XSS vulnerabilities.
        /// </summary>
        public static List<VulnerabilityReport> ScanForXss(string code)
        {
            var vulnerabilities = new List<VulnerabilityReport>();

            // Pattern 1: HTML content without HtmlEncode
            var htmlContentPattern = @"Results\.Content\s*\(.*text/html";
            if (Regex.IsMatch(code, htmlContentPattern, RegexOptions.IgnoreCase | RegexOptions.Singleline))
            {
                // Check if HtmlEncode is missing
                if (!Regex.IsMatch(code, @"HtmlEncode", RegexOptions.IgnoreCase))
                {
                    vulnerabilities.Add(new VulnerabilityReport
                    {
                        Type = "Cross-Site Scripting (XSS)",
                        Severity = "HIGH",
                        Location = "HTML Response without Encoding",
                        Description = "HTML content is being returned without proper encoding. User input could be executed as script.",
                        Recommendation = "Use System.Web.HttpUtility.HtmlEncode() to encode all user-generated content before output."
                    });
                }
            }

            // Pattern 2: Direct string interpolation in responses
            var messagePattern = @"message\s*=\s*\$"".*\{.*\}";
            if (Regex.IsMatch(code, messagePattern, RegexOptions.IgnoreCase))
            {
                // Check if it's in a Results.Ok or similar
                if (Regex.IsMatch(code, @"Results\.(Ok|Content|Json).*message.*\$""", RegexOptions.IgnoreCase | RegexOptions.Singleline))
                {
                    vulnerabilities.Add(new VulnerabilityReport
                    {
                        Type = "Cross-Site Scripting (XSS)",
                        Severity = "MEDIUM",
                        Location = "Unencoded User Input in Response",
                        Description = "User input is being directly interpolated into response messages without encoding.",
                        Recommendation = "Encode user input with HtmlEncode before including in responses."
                    });
                }
            }

            // Pattern 3: Missing input validation
            var formDataPattern = @"form\["".*""\]\.ToString\(\)";
            if (Regex.IsMatch(code, formDataPattern))
            {
                // Check if validation is missing
                if (!Regex.IsMatch(code, @"Validate|IsValid|validator", RegexOptions.IgnoreCase))
                {
                    vulnerabilities.Add(new VulnerabilityReport
                    {
                        Type = "Missing Input Validation",
                        Severity = "MEDIUM",
                        Location = "Form Data Processing",
                        Description = "Form data is being processed without validation or sanitization.",
                        Recommendation = "Validate all user inputs using InputValidationService before processing."
                    });
                }
            }

            return vulnerabilities;
        }

        /// <summary>
        /// Scans code for missing authentication/authorization.
        /// </summary>
        public static List<VulnerabilityReport> ScanForAuthIssues(string code)
        {
            var vulnerabilities = new List<VulnerabilityReport>();

            // Pattern: Endpoints without RequireAuthorization
            var mapGetPattern = @"app\.Map(Get|Post|Put|Delete)\s*\(";
            var requireAuthPattern = @"\.RequireAuthorization\s*\(";

            var matches = Regex.Matches(code, mapGetPattern);
            var authMatches = Regex.Matches(code, requireAuthPattern);

            if (matches.Count > authMatches.Count)
            {
                vulnerabilities.Add(new VulnerabilityReport
                {
                    Type = "Missing Authorization",
                    Severity = "MEDIUM",
                    Location = "Endpoint Definition",
                    Description = "Some endpoints may be missing authentication/authorization requirements.",
                    Recommendation = "Review all endpoints and add .RequireAuthorization() where appropriate."
                });
            }

            return vulnerabilities;
        }

        /// <summary>
        /// Performs a comprehensive security scan on provided code.
        /// </summary>
        public static SecurityScanResult PerformSecurityScan(string code)
        {
            var result = new SecurityScanResult
            {
                ScanDate = DateTime.UtcNow,
                TotalVulnerabilities = 0
            };

            result.SqlInjectionIssues = ScanForSqlInjection(code);
            result.XssIssues = ScanForXss(code);
            result.AuthorizationIssues = ScanForAuthIssues(code);

            result.TotalVulnerabilities = 
                result.SqlInjectionIssues.Count + 
                result.XssIssues.Count + 
                result.AuthorizationIssues.Count;

            result.CriticalCount = result.AllVulnerabilities
                .Count(v => v.Severity == "CRITICAL");
            result.HighCount = result.AllVulnerabilities
                .Count(v => v.Severity == "HIGH");
            result.MediumCount = result.AllVulnerabilities
                .Count(v => v.Severity == "MEDIUM");

            return result;
        }
    }

    /// <summary>
    /// Represents a single vulnerability finding.
    /// </summary>
    public class VulnerabilityReport
    {
        public string Type { get; set; } = string.Empty;
        public string Severity { get; set; } = string.Empty;
        public string Location { get; set; } = string.Empty;
        public string Description { get; set; } = string.Empty;
        public string Recommendation { get; set; } = string.Empty;

        public override string ToString()
        {
            return $"[{Severity}] {Type} at {Location}: {Description}";
        }
    }

    /// <summary>
    /// Results from a comprehensive security scan.
    /// </summary>
    public class SecurityScanResult
    {
        public DateTime ScanDate { get; set; }
        public List<VulnerabilityReport> SqlInjectionIssues { get; set; } = new();
        public List<VulnerabilityReport> XssIssues { get; set; } = new();
        public List<VulnerabilityReport> AuthorizationIssues { get; set; } = new();
        public int TotalVulnerabilities { get; set; }
        public int CriticalCount { get; set; }
        public int HighCount { get; set; }
        public int MediumCount { get; set; }

        public List<VulnerabilityReport> AllVulnerabilities
        {
            get
            {
                var all = new List<VulnerabilityReport>();
                all.AddRange(SqlInjectionIssues);
                all.AddRange(XssIssues);
                all.AddRange(AuthorizationIssues);
                return all;
            }
        }

        public string GenerateReport()
        {
            var report = new System.Text.StringBuilder();
            report.AppendLine("╔══════════════════════════════════════════════════════════╗");
            report.AppendLine("║           SECURITY VULNERABILITY SCAN REPORT            ║");
            report.AppendLine("╠══════════════════════════════════════════════════════════╣");
            report.AppendLine($"║  Scan Date:           {ScanDate:yyyy-MM-dd HH:mm:ss}            ║");
            report.AppendLine($"║  Total Issues:        {TotalVulnerabilities,-2}                                   ║");
            report.AppendLine($"║  Critical:            {CriticalCount,-2}                                   ║");
            report.AppendLine($"║  High:                {HighCount,-2}                                   ║");
            report.AppendLine($"║  Medium:              {MediumCount,-2}                                   ║");
            report.AppendLine("╚══════════════════════════════════════════════════════════╝");
            report.AppendLine();

            if (SqlInjectionIssues.Count > 0)
            {
                report.AppendLine("SQL INJECTION VULNERABILITIES:");
                report.AppendLine("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
                foreach (var issue in SqlInjectionIssues)
                {
                    report.AppendLine($"  [{issue.Severity}] {issue.Location}");
                    report.AppendLine($"  Description: {issue.Description}");
                    report.AppendLine($"  Fix: {issue.Recommendation}");
                    report.AppendLine();
                }
            }

            if (XssIssues.Count > 0)
            {
                report.AppendLine("CROSS-SITE SCRIPTING (XSS) VULNERABILITIES:");
                report.AppendLine("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
                foreach (var issue in XssIssues)
                {
                    report.AppendLine($"  [{issue.Severity}] {issue.Location}");
                    report.AppendLine($"  Description: {issue.Description}");
                    report.AppendLine($"  Fix: {issue.Recommendation}");
                    report.AppendLine();
                }
            }

            if (AuthorizationIssues.Count > 0)
            {
                report.AppendLine("AUTHORIZATION ISSUES:");
                report.AppendLine("━━━━━━━━━━━━━━━━━━━━━");
                foreach (var issue in AuthorizationIssues)
                {
                    report.AppendLine($"  [{issue.Severity}] {issue.Location}");
                    report.AppendLine($"  Description: {issue.Description}");
                    report.AppendLine($"  Fix: {issue.Recommendation}");
                    report.AppendLine();
                }
            }

            if (TotalVulnerabilities == 0)
            {
                report.AppendLine("✓ No vulnerabilities detected.");
            }

            return report.ToString();
        }
    }
}
